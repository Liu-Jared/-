// ==UserScript==
// @name         Google Translate Automation with Improved Status Detection and Scrolling
// @namespace    http://tampermonkey.net/
// @version      2.53
// @description  Automatically translate and input text using Google API via Tampermonkey, with improved detection of translation status and correct scrolling
// @author
// @match        *://*/*
// @grant        GM_download
// ==/UserScript==

(function () {
    'use strict';

    window.addEventListener('load', function () {
        createUI();
        updateStatus('脚本已加载并初始化', 'INFO');
    });

    const supportedLanguages = [
        'ar', 'hr', 'cs', 'en', 'fr', 'de', 'hi', 'hu', 'id', 'ja', 'lt', 'fa', 'pl',
        'pt-br', 'ro', 'ru', 'es', 'th', 'tr', 'uz', 'vi'
    ];

    const languageCodeMap = {
        'ar': 'ar',
        'hr': 'hr',
        'cs': 'cs',
        'en': 'en',
        'fr': 'fr',
        'de': 'de',
        'hi': 'hi',
        'hu': 'hu',
        'id': 'id',
        'ja': 'ja',
        'lt': 'lt',
        'fa': 'fa',
        'pl': 'pl',
        'pt-br': 'pt',
        'ro': 'ro',
        'ru': 'ru',
        'es': 'es',
        'th': 'th',
        'tr': 'tr',
        'uz': 'uz',
        'vi': 'vi'
        // 其他语言代码映射
    };

    let stopExecution = false;
    let abortController = new AbortController();
    let logMessages = []; // 用于存储日志消息

    const API_KEY = 'AIzaSyBjtJYG3psVo7Eg2-2duSonBCEGP27jNqE'; // 请在此替换为您的Google API密钥
    const API_URL = `https://translation.googleapis.com/language/translate/v2?key=${API_KEY}`;

    function createUI() {
        updateStatus('执行 createUI 函数，创建界面元素', 'DEBUG');

        // 创建“开始翻译”按钮
        const startButton = document.createElement('button');
        startButton.textContent = '开始翻译';
        setButtonStyle(startButton, '10px');
        startButton.addEventListener('click', startTranslation);
        document.body.appendChild(startButton);

        // 创建“停止检测”按钮
        const stopButton = document.createElement('button');
        stopButton.textContent = '停止检测';
        setButtonStyle(stopButton, '50px');
        stopButton.addEventListener('click', () => {
            stopExecution = true;
            abortController.abort();
            abortController = new AbortController();
            updateStatus('检测已停止', 'INFO');
        });
        document.body.appendChild(stopButton);

        // 创建“清除已翻译索引”按钮
        const clearButton = document.createElement('button');
        clearButton.textContent = '清除已翻译索引';
        setButtonStyle(clearButton, '90px');
        clearButton.addEventListener('click', () => {
            sessionStorage.removeItem('translatedIndexes');
            updateStatus('已清除所有已翻译索引', 'INFO');
            updateTranslatedIndexDisplay();
        });
        document.body.appendChild(clearButton);

        // 创建“下载日志”按钮
        const downloadLogButton = document.createElement('button');
        downloadLogButton.textContent = '下载日志';
        setButtonStyle(downloadLogButton, '130px');
        downloadLogButton.addEventListener('click', downloadLog);
        document.body.appendChild(downloadLogButton);

        // 创建已翻译索引的显示区域
        const translatedIndexDisplay = document.createElement('div');
        translatedIndexDisplay.id = 'translated-index-display';
        setDisplayStyle(translatedIndexDisplay, '170px');
        document.body.appendChild(translatedIndexDisplay);
        updateTranslatedIndexDisplay();

        // 创建状态显示区域
        const statusDiv = document.createElement('div');
        statusDiv.id = 'script-status';
        setDisplayStyle(statusDiv, '400px');
        document.body.appendChild(statusDiv);

        updateStatus('界面创建完成', 'INFO');
    }

    function setButtonStyle(button, topPosition) {
        button.style.position = 'fixed';
        button.style.top = topPosition;
        button.style.right = '10px';
        button.style.zIndex = 1000;
        button.style.padding = '10px 20px';
        button.style.backgroundColor = '#007bff';
        button.style.color = '#fff';
        button.style.border = 'none';
        button.style.borderRadius = '5px';
        button.style.cursor = 'pointer';
        button.style.fontSize = '14px';
        button.style.marginBottom = '5px';
    }

    function setDisplayStyle(div, topPosition) {
        div.style.position = 'fixed';
        div.style.top = topPosition;
        div.style.right = '10px';
        div.style.zIndex = 1000;
        div.style.padding = '10px 20px';
        div.style.backgroundColor = '#fff';
        div.style.border = '1px solid #ddd';
        div.style.borderRadius = '5px';
        div.style.maxWidth = '300px';
        div.style.maxHeight = '200px';
        div.style.overflowY = 'auto';
    }

    function updateTranslatedIndexDisplay() {
        updateStatus('执行 updateTranslatedIndexDisplay 函数', 'DEBUG');

        const translatedIndexes = getTranslatedIndexes();
        const displayDiv = document.getElementById('translated-index-display');
        if (displayDiv) {
            displayDiv.innerHTML = `已翻译索引: ${translatedIndexes.size > 0 ? Array.from(translatedIndexes).join(', ') : '无'}`;
        }
    }

    function updateStatus(message, level = 'INFO') {
        const statusDiv = document.getElementById('script-status');
        if (statusDiv) {
            const timestamp = new Date().toLocaleTimeString();
            const statusMessage = document.createElement('p');
            statusMessage.innerHTML = `[${timestamp}] [${level}] ${message}`;
            statusDiv.prepend(statusMessage);

            // 滚动到顶部以显示最新的状态消息
            statusDiv.scrollTop = 0;

            // 自动隐藏旧的状态消息
            setTimeout(() => {
                statusMessage.remove();
            }, 10000);

            // 将消息添加到日志
            logMessages.push(`[${timestamp}] [${level}] ${message}`);
        }
    }

    function getLanguages() {
        updateStatus('执行 getLanguages 函数，检测语言设置', 'DEBUG');

        let originalLang = null;
        let translationLang = null;

        document.querySelectorAll('div.sc-dlWCHZ').forEach((div) => {
            const span = div.querySelector('span');
            const spanText = span ? span.textContent.trim() : '';
            if (spanText === 'Original') {
                const img = div.querySelector('h5 img');
                if (img) originalLang = img.getAttribute('alt');
            } else if (spanText === 'Translation') {
                const img = div.querySelector('h5 img');
                if (img) translationLang = img.getAttribute('alt');
            }
        });

        originalLang = languageCodeMap[originalLang] || originalLang;
        translationLang = languageCodeMap[translationLang] || translationLang;

        if (!originalLang || !translationLang || !supportedLanguages.includes(originalLang) || !supportedLanguages.includes(translationLang)) {
            updateStatus(`检测到的语言:\n原文: ${originalLang || '未找到'}\n目标: ${translationLang || '未找到'}\n一个或两个语言不被支持。`, 'ERROR');
            return { originalLang: null, translationLang: null };
        }

        updateStatus(`检测到的语言: 原文: ${originalLang}, 目标: ${translationLang}`, 'INFO');
        return { originalLang, translationLang };
    }

    function highlightElement(element) {
        updateStatus('执行 highlightElement 函数，突出显示元素', 'DEBUG');

        element.style.border = '2px solid red';
        element.style.backgroundColor = '#ffcccc';
        element.style.transition = 'background-color 0.5s ease';
        setTimeout(() => clearHighlight(element), 1500);
    }

    function clearHighlight(element) {
        element.style.border = '';
        element.style.backgroundColor = '';
    }

    function getTranslatedIndexes() {
        const translatedIndexes = sessionStorage.getItem('translatedIndexes');
        return translatedIndexes ? new Set(JSON.parse(translatedIndexes)) : new Set();
    }

    function saveTranslatedIndex(index) {
        updateStatus(`执行 saveTranslatedIndex 函数，保存已翻译索引: ${index}`, 'DEBUG');

        const translatedIndexes = getTranslatedIndexes();
        if (!translatedIndexes.has(index)) {
            translatedIndexes.add(index);
            sessionStorage.setItem('translatedIndexes', JSON.stringify(Array.from(translatedIndexes)));
            updateTranslatedIndexDisplay();
        }
    }

    // 修正后的 getTranslationStatus 函数
    function getTranslationStatus(element) {
        updateStatus('执行 getTranslationStatus 函数，获取翻译状态', 'DEBUG');

        // 精确选择翻译状态的元素
        const statusDiv = element.querySelector('.sc-SrznA .ate-tooltip-dropdown');
        if (statusDiv) {
            return statusDiv.textContent.trim();
        }
        return null;
    }

    // 新增函数：检测编辑器是否打开
    function isEditorOpen() {
        const iframe = document.querySelector('iframe[id^="tiny-react"]');
        return !!iframe;
    }

    async function processCurrentEditor(originalLang, translationLang, currentDataIndex) {
        updateStatus(`执行 processCurrentEditor 函数，处理 data-index: ${currentDataIndex}`, 'DEBUG');

        if (stopExecution) {
            updateStatus('停止执行 processCurrentEditor，因为 stopExecution 为真', 'INFO');
            return;
        }

        try {
            // 此时编辑器应该已经打开，继续处理需要翻译的情况

            const iframe = document.querySelector('iframe[id^="tiny-react"]');
            if (!iframe) {
                updateStatus('编辑器未打开，无法处理', 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            if (currentDataIndex === null || currentDataIndex === undefined) {
                updateStatus('currentDataIndex 未提供，无法处理', 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            const currentElement = document.querySelector(`[data-index="${currentDataIndex}"]`);
            if (!currentElement) {
                updateStatus(`无法找到 data-index 为 ${currentDataIndex} 的元素`, 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            // 此处不再需要重新获取 statusText，因为主循环已处理
            // 直接进行翻译处理

            const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
            const body = iframeDocument.querySelector('body#tinymce');

            if (!body) {
                updateStatus('未找到编辑器 body，无法插入翻译文本', 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            body.innerHTML = '';
            updateStatus(`清空编辑器内容，准备插入翻译文本，处理 data-index: ${currentDataIndex}`, 'DEBUG');

            const originalTextDiv = currentElement.querySelector('div.segm.AT-segment_list__original');
            if (originalTextDiv) {
                const originalText = originalTextDiv.textContent.trim();
                updateStatus(`提取原文: ${originalText}`, 'INFO');

                try {
                    const translatedText = await translateTextWithLineBreaks(originalText, originalLang, translationLang);
                    if (!translatedText || translatedText.trim() === '') {
                        updateStatus(`翻译失败，未获得翻译结果，跳过 data-index: ${currentDataIndex}`, 'ERROR');
                        // 关闭编辑器并跳过此段落
                        const closeButton = document.querySelector('.AT-editor__close');
                        if (closeButton) {
                            closeButton.click();
                            updateStatus(`关闭编辑器，处理 data-index: ${currentDataIndex}`, 'INFO');
                        }
                        // 记录已处理索引以避免重复处理
                        saveTranslatedIndex(currentDataIndex);
                        // 不再返回，确保主循环继续
                        await new Promise(resolve => setTimeout(resolve, 500));
                        return;
                    }

                    updateStatus(`翻译后的文本: ${translatedText}`, 'INFO');

                    body.innerHTML = `<p>${translatedText.replace(/\n/g, '<br>')}</p>`;
                    updateStatus(`插入翻译文本到编辑器，处理 data-index: ${currentDataIndex}`, 'DEBUG');

                    const saveButton = document.querySelector('.AT-editor__complete_segment');
                    if (saveButton) {
                        saveButton.click();
                        updateStatus(`点击保存按钮，处理 data-index: ${currentDataIndex}`, 'INFO');
                        saveTranslatedIndex(currentDataIndex);

                        // 等待保存完成
                        await new Promise(resolve => setTimeout(resolve, 1000));
                    } else {
                        updateStatus(`未找到保存按钮，处理 data-index: ${currentDataIndex}`, 'ERROR');
                        saveTranslatedIndex(currentDataIndex);
                    }
                } catch (error) {
                    updateStatus(`翻译失败，处理 data-index: ${currentDataIndex}: ${error}`, 'ERROR');
                    console.error(`翻译失败: ${error.message}`);
                    // 关闭编辑器并跳过此段落
                    const closeButton = document.querySelector('.AT-editor__close');
                    if (closeButton) {
                        closeButton.click();
                        updateStatus(`关闭编辑器，处理 data-index: ${currentDataIndex}`, 'INFO');
                    }
                    // 记录已处理索引以避免重复处理
                    saveTranslatedIndex(currentDataIndex);
                    // 不再返回，确保主循环继续
                    await new Promise(resolve => setTimeout(resolve, 500));
                }
            } else {
                updateStatus(`未找到原文，处理 data-index: ${currentDataIndex}`, 'ERROR');
                saveTranslatedIndex(currentDataIndex);
            }
        } catch (e) {
            updateStatus(`处理 data-index: ${currentDataIndex} 时发生错误: ${e.message}`, 'ERROR');
            console.error(e);
            saveTranslatedIndex(currentDataIndex);
            // 不再返回，确保主循环继续
        }
    }

    async function startTranslation() {
        updateStatus('执行 startTranslation 函数，开始翻译流程', 'INFO');

        stopExecution = false;
        abortController = new AbortController();

        const { originalLang, translationLang } = getLanguages();
        if (!originalLang || !translationLang) {
            updateStatus('语言检测失败，无法开始翻译', 'ERROR');
            return;
        }

        // 检查是否还有未处理的 data-index 元素
        await checkDataIndexElements(originalLang, translationLang);
    }

    async function checkDataIndexElements(originalLang, translationLang) {
        updateStatus('执行 checkDataIndexElements 函数，开始检测 data-index 元素', 'INFO');

        // 获取滚动容器
        const scroller = document.querySelector('div[data-test-id="virtuoso-scroller"][data-virtuoso-scroller="true"]');
        if (!scroller) {
            updateStatus('未找到滚动容器，无法继续执行', 'ERROR');
            return;
        }

        while (!stopExecution) {
            try {
                const translatedIndexes = getTranslatedIndexes(); // 在这里获取最新的 translatedIndexes

                let dataIndexElements = Array.from(scroller.querySelectorAll('[data-index]'));

                // 过滤有效的 data-index
                dataIndexElements = dataIndexElements.filter(element => {
                    const dataIndex = element.getAttribute('data-index');
                    return /^\d+$/.test(dataIndex) && parseInt(dataIndex) > 0 && !translatedIndexes.has(parseInt(dataIndex));
                });

                // 如果没有未处理的元素，等待一段时间后重新检查
                if (dataIndexElements.length === 0) {
                    updateStatus('当前没有未处理的 data-index 元素，等待新的元素出现...', 'INFO');
                    await new Promise(resolve => setTimeout(resolve, 3000)); // 每3秒检查一次
                    continue;
                }

                // 按 data-index 从小到大排序
                dataIndexElements.sort((a, b) => {
                    const aIndex = parseInt(a.getAttribute('data-index'));
                    const bIndex = parseInt(b.getAttribute('data-index'));
                    return aIndex - bIndex;
                });

                // 添加日志以验证排序
                const sortedIndices = dataIndexElements.map(el => el.getAttribute('data-index'));
                updateStatus(`排序后的 data-index 元素顺序: ${sortedIndices.join(', ')}`, 'DEBUG');

                const element = dataIndexElements[0];
                const dataIndex = parseInt(element.getAttribute('data-index'), 10);

                updateStatus(`正在处理 data-index: ${dataIndex}`, 'INFO');

                // 将元素滚动到滚动容器的视口中心
                await scrollElementIntoView(scroller, element);
                updateStatus(`滚动到 data-index: ${dataIndex} 的元素`, 'DEBUG');
                await new Promise(resolve => setTimeout(resolve, 1000)); // 等待滚动完成

                highlightElement(element);

                // 检查是否包含 et_pb_image
                const containsEtPbImage = element.querySelector('span.sc-aXZVg.fNmccr.AT-ate-chip--segment.ate-chip.ate-chip--segment')?.textContent.includes('et_pb_image');
                if (containsEtPbImage) {
                    updateStatus(`data-index: ${dataIndex} 包含 et_pb_image，执行相应操作`, 'INFO');

                    // 打开编辑器
                    const clickableElement = element.querySelector('button') || element.querySelector('.ate-tooltip-dropdown');
                    if (clickableElement) {
                        clickableElement.click();
                        updateStatus(`点击元素打开编辑器，处理 data-index: ${dataIndex}`, 'INFO');

                        // 等待编辑器加载
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // 处理打开的编辑器，传递 dataIndex
                        await handleEtPbImageElement(originalLang, translationLang, dataIndex);
                    } else {
                        updateStatus(`未找到可点击的元素以打开编辑器，处理 data-index: ${dataIndex}`, 'ERROR');
                        saveTranslatedIndex(dataIndex);
                    }

                    // 标记为已处理
                    saveTranslatedIndex(dataIndex);
                } else {
                    // 不包含 et_pb_image，继续常规处理
                    const statusText = getTranslationStatus(element);
                    if (statusText) {
                        updateStatus(`data-index: ${dataIndex}，状态: ${statusText}`, 'INFO');

                        if (statusText !== 'No translation') {
                            // 状态不是 'No translation'，检测编辑器是否打开
                            if (isEditorOpen()) {
                                const closeButton = document.querySelector('.ate-icon-button.AT-segment_list__close_translation_button');
                                if (closeButton) {
                                    closeButton.click();
                                    updateStatus(`状态不是 'No translation'，关闭编辑器，处理 data-index: ${dataIndex}`, 'INFO');
                                } else {
                                    updateStatus(`状态不是 'No translation'，但未找到关闭按钮，处理 data-index: ${dataIndex}`, 'ERROR');
                                }
                            } else {
                                updateStatus(`状态不是 'No translation'，编辑器未打开，跳过 data-index: ${dataIndex}`, 'INFO');
                            }
                            // 标记为已处理
                            saveTranslatedIndex(dataIndex);
                        } else {
                            // 状态是 'No translation'，继续打开编辑器并翻译
                            const clickableElement = element.querySelector('button') || element.querySelector('.ate-tooltip-dropdown');
                            if (clickableElement) {
                                clickableElement.click();
                                updateStatus(`点击元素打开编辑器，处理 data-index: ${dataIndex}`, 'INFO');

                                // 等待编辑器加载
                                await new Promise(resolve => setTimeout(resolve, 500));

                                // 处理打开的编辑器，传递 dataIndex
                                await processCurrentEditor(originalLang, translationLang, dataIndex);
                            } else {
                                updateStatus(`未找到可点击的元素，处理 data-index: ${dataIndex}`, 'ERROR');
                                saveTranslatedIndex(dataIndex);
                            }
                        }
                    } else {
                        updateStatus(`未找到状态元素，处理 data-index: ${dataIndex}`, 'ERROR');
                        saveTranslatedIndex(dataIndex);
                    }
                }

                // 等待片刻再处理下一个元素，避免过快操作导致问题
                await new Promise(resolve => setTimeout(resolve, 500));
            } catch (error) {
                updateStatus(`在检测和处理 data-index 元素时发生错误: ${error.message}`, 'ERROR');
                console.error(error);
                // 等待一段时间后继续
                await new Promise(resolve => setTimeout(resolve, 3000));
            }
        }

        updateStatus('检测已停止或完成', 'INFO');
    }

    // 新增函数：在指定的滚动容器中滚动到目标元素
    async function scrollElementIntoView(container, element) {
        try {
            // 获取元素相对于容器的位置
            const containerRect = container.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();

            // 计算元素在容器中的位置
            const offsetTop = element.offsetTop;

            // 计算需要滚动的目标位置，将元素置于容器中心
            const scrollTo = offsetTop - (container.clientHeight / 2) + (element.clientHeight / 2);

            // 执行滚动
            container.scrollTo({
                top: scrollTo,
                behavior: 'smooth'
            });

            updateStatus(`滚动容器到位置: ${scrollTo}`, 'DEBUG');

            // 等待滚动完成（根据需要调整时间）
            await new Promise(resolve => setTimeout(resolve, 800));

            // 确认元素已进入视口
            const newElementRect = element.getBoundingClientRect();
            const newContainerRect = container.getBoundingClientRect();

            if (
                newElementRect.top < newContainerRect.top ||
                newElementRect.bottom > newContainerRect.bottom
            ) {
                updateStatus(`元素 data-index: ${element.getAttribute('data-index')} 未完全进入视口，可能需要手动调整。`, 'WARN');
            } else {
                updateStatus(`元素 data-index: ${element.getAttribute('data-index')} 已成功滚动到视口。`, 'INFO');
            }
        } catch (error) {
            updateStatus(`滚动到元素时发生错误: ${error.message}`, 'ERROR');
            console.error(error);
        }
    }

    async function translateTextWithLineBreaks(text, fromLang, toLang) {
        updateStatus('执行 translateTextWithLineBreaks 函数，处理文本换行', 'DEBUG');

        const segments = text.split('\n');
        const translatedSegments = [];

        for (let segment of segments) {
            if (stopExecution) {
                updateStatus('停止执行 translateTextWithLineBreaks，因为 stopExecution 为真', 'INFO');
                return '';
            }
            if (segment.trim() === '') {
                translatedSegments.push('');
            } else {
                try {
                    const translatedSegment = await translateText(segment, fromLang, toLang);
                    translatedSegments.push(translatedSegment);
                    // 等待片刻，避免 API 请求过于频繁
                    await new Promise(resolve => setTimeout(resolve, 200));
                } catch (error) {
                    updateStatus(`翻译段落出错: ${error.message}`, 'ERROR');
                    translatedSegments.push(segment);
                }
            }
        }

        return translatedSegments.join('\n');
    }

    async function translateText(query, fromLang, toLang) {
        updateStatus(`执行 translateText 函数，翻译文本: ${query}`, 'DEBUG');

        // 对请求的文本进行编码，以防止特殊字符导致请求失败
        const safeQuery = query.replace(/#[^\s]+/g, '').trim();

        const response = await fetch(API_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                q: safeQuery,
                source: fromLang,
                target: toLang,
                format: 'text'
            }),
            signal: abortController.signal
        });

        if (!response.ok) {
            const errorText = await response.text();
            updateStatus(`HTTP 错误! 状态: ${response.status}, 信息: ${errorText}`, 'ERROR');
            throw new Error(`HTTP 错误! 状态: ${response.status}, 信息: ${errorText}`);
        }

        const data = await response.json();
        if (data && data.data && data.data.translations) {
            updateStatus(`翻译成功: ${data.data.translations[0].translatedText}`, 'DEBUG');
            return data.data.translations[0].translatedText;
        } else {
            updateStatus(`翻译 API 错误: ${data.error.message || '翻译失败'}`, 'ERROR');
            throw new Error(data.error.message || '翻译失败');
        }
    }

    function downloadLog() {
        updateStatus('执行 downloadLog 函数，准备下载日志', 'INFO');

        if (logMessages.length === 0) {
            updateStatus('日志为空，无需下载', 'INFO');
            return;
        }

        const blob = new Blob([logMessages.join('\n')], { type: 'text/plain;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        const link = document.createElement('a');
        link.href = url;
        link.download = `translation_log_${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.txt`;
        document.body.appendChild(link);
        link.click();

        // 清理
        document.body.removeChild(link);
        URL.revokeObjectURL(url);

        updateStatus('日志已下载', 'INFO');
    }

    // 新增函数：处理包含 et_pb_image 的 data-index 元素
    async function handleEtPbImageElement(originalLang, translationLang, currentDataIndex) {
        updateStatus(`执行 handleEtPbImageElement 函数，处理 data-index: ${currentDataIndex}`, 'DEBUG');

        if (stopExecution) {
            updateStatus('停止执行 handleEtPbImageElement，因为 stopExecution 为真', 'INFO');
            return;
        }

        try {
            const iframe = document.querySelector('iframe[id^="tiny-react"]');
            if (!iframe) {
                updateStatus('编辑器未打开，无法处理 et_pb_image 元素', 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            const currentElement = document.querySelector(`[data-index="${currentDataIndex}"]`);
            if (!currentElement) {
                updateStatus(`无法找到 data-index 为 ${currentDataIndex} 的元素`, 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            const iframeDocument = iframe.contentDocument || iframe.contentWindow.document;
            const body = iframeDocument.querySelector('body#tinymce');

            if (!body) {
                updateStatus('未找到编辑器 body，无法插入原文', 'ERROR');
                saveTranslatedIndex(currentDataIndex);
                return; // 改为不影响主循环
            }

            // 获取原文
            const originalTextDiv = currentElement.querySelector('div.segm.AT-segment_list__original');
            if (originalTextDiv) {
                const originalText = originalTextDiv.textContent.trim();
                updateStatus(`提取原文: ${originalText}`, 'INFO');

                // 填充编辑器内容为原文
                body.innerHTML = `<p>${originalText.replace(/\n/g, '<br>')}</p>`;
                updateStatus(`插入原文到编辑器，处理 data-index: ${currentDataIndex}`, 'DEBUG');

                // 点击保存按钮
                const saveButton = document.querySelector('.AT-editor__complete_segment');
                if (saveButton) {
                    saveButton.click();
                    updateStatus(`点击保存按钮，处理 data-index: ${currentDataIndex}`, 'INFO');
                    saveTranslatedIndex(currentDataIndex);

                    // 等待保存完成
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } else {
                    updateStatus(`未找到保存按钮，处理 data-index: ${currentDataIndex}`, 'ERROR');
                    saveTranslatedIndex(currentDataIndex);
                }
            } else {
                updateStatus(`未找到原文，处理 data-index: ${currentDataIndex}`, 'ERROR');
                saveTranslatedIndex(currentDataIndex);
            }
        } catch (e) {
            updateStatus(`处理 data-index: ${currentDataIndex} 时发生错误: ${e.message}`, 'ERROR');
            console.error(e);
            saveTranslatedIndex(currentDataIndex);
            // 不再返回，确保主循环继续
        }
    }

})();
